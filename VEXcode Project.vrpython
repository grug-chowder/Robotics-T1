{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\nmyVariable = 0\n\ndef when_started1():\n    global myVariable\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n\n    centre()\n    pen.move(DOWN)\n    fpath = mapout()\n    qpath = compress_path(fpath,[-125,875])\n    pen.set_pen_color(RED)\n    exec_path(qpath)\n    rev_path(qpath)\n    pen.set_pen_color(GREEN)\n    exec_path(qpth)\n    drivetrain.turn_to_heading(0, DEGREES)\n    drivetrain.drive(FORWARD)\n    pass\n\nvr_thread(when_started1)\n\ndef edgemove(x):#checks if moves dont go out of bounds moveing if possible\n    if ((drivetrain.heading(DEGREES) == 0 and \n        location.position(Y, MM) + x < 900) or\n        (drivetrain.heading(DEGREES) == 180 and \n        location.position(Y, MM) - x > -900)):\n        drivetrain.drive_for(FORWARD, x, MM)\n        return True\n    else:\n        return False\n\n        \n\n    \ndef centre(): #centers bot to consistent position\n    xmod,ymod = 1,1\n    while xmod != 0  and ymod != 0:\n        xmod = (location.position(X,MM) % 250) - 125\n        ymod = (location.position(Y,MM) % 250) - 125\n\n        \n        if(xmod != 0):\n            drivetrain.turn_to_heading(270, DEGREES)\n            drivetrain.drive_for(FORWARD, xmod, MM)\n        \n        if(ymod != 0):\n            drivetrain.turn_to_heading(0, DEGREES)\n            drivetrain.drive_for(REVERSE, ymod, MM)\n\ndef mapout():\n    path = [[location.position(X,MM),location.position(Y,MM),0,0]]\n    centre()\n    while True:\n        \n        #follow left wall\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        while front_distance.get_distance(MM) <= 250:\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n        #brain.print(front_distance.get_distance(MM))\n        #brain.new_line()\n        if front_distance.get_distance(MM) > 2000:\n            x = edgemove(250)\n            if x == False:\n                drivetrain.turn_for(LEFT, 180, DEGREES)\n                continue\n\n        else:\n            drivetrain.drive_for(FORWARD, 250, MM)\n        centre()\n        path.append([location.position(X,MM),location.position(Y,MM),drivetrain.heading(DEGREES),250])\n        if path[0][0] == location.position(X,MM) and path[0][1] == location.position(Y,MM):\n            path2 = [(i[0],i[1]) for i in path]\n            if (375,-875) in path2 and (125,-625) in path2 and (-125,-875) in path2:\n                break\n\n\n    return path\n        \n\ndef compress_path(path,goal):#takes the path of a full circuit of the maze and returns the quickest path to the exit\n    newpath = []\n    \n    for i in path:\n        \n        if i[0] == goal[0] and i[1] == goal[1]:#if we have reached the end\n            newpath.append(i)\n            break\n\n\n        squad = [(item[0],item[1]) for item in newpath]\n        if ((i[0],i[1]) in squad):#if the quords have been used before\n            print(i)\n            pl = len(newpath) #remove everything to last quordinate copy\n            for j in reversed(newpath):\n                print(j)\n                print(newpath)\n                if j[0] != i[0] or j[1] != i[1]:\n                    print(\"killtime\")\n                    del newpath[-1]\n                else:\n                    break\n        else:\n            newpath.append(i)\n    return newpath\n\ndef exec_path(path):\n    for i in path:\n        drivetrain.turn_to_heading(i[2],DEGREES)\n        drivetrain.drive_for(FORWARD,i[3],MM)\n\ndef rev_path(path):\n    path.reverse()\n    for i in path:\n        drivetrain.turn_to_heading(i[2],DEGREES)\n        drivetrain.drive_for(REVERSE,i[3],MM)\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}