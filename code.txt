#region VEXcode Generated Robot Configuration
import math
import random
from vexcode_vr import *

# Brain should be defined by default
brain=Brain()

drivetrain = Drivetrain("drivetrain", 0)
pen = Pen("pen", 8)
pen.set_pen_width(THIN)
left_bumper = Bumper("leftBumper", 2)
right_bumper = Bumper("rightBumper", 3)
front_eye = EyeSensor("frontEye", 4)
down_eye = EyeSensor("downEye", 5)
front_distance = Distance("frontdistance", 6)
distance = front_distance
magnet = Electromagnet("magnet", 7)
location = Location("location", 9)

#endregion VEXcode Generated Robot Configuration
myVariable = 0

def when_started1():
    global myVariable
    drivetrain.set_drive_velocity(100, PERCENT)
    drivetrain.set_turn_velocity(100, PERCENT)

    centre()
    pen.move(DOWN)
    fpath = mapout()
    qpath = compress_path(fpath,[-125,875])
    pen.set_pen_color(RED)
    exec_path(qpath)
    rev_path(qpath)
    pen.set_pen_color(GREEN)
    exec_path(qpth)
    drivetrain.turn_to_heading(0, DEGREES)
    drivetrain.drive(FORWARD)
    pass

vr_thread(when_started1)

def edgemove(x):#checks if moves dont go out of bounds moveing if possible
    if ((drivetrain.heading(DEGREES) == 0 and 
        location.position(Y, MM) + x < 900) or
        (drivetrain.heading(DEGREES) == 180 and 
        location.position(Y, MM) - x > -900)):
        drivetrain.drive_for(FORWARD, x, MM)
        return True
    else:
        return False

        

    
def centre(): #centers bot to consistent position
    xmod,ymod = 1,1
    while xmod != 0  and ymod != 0:
        xmod = (location.position(X,MM) % 250) - 125
        ymod = (location.position(Y,MM) % 250) - 125

        
        if(xmod != 0):
            drivetrain.turn_to_heading(270, DEGREES)
            drivetrain.drive_for(FORWARD, xmod, MM)
        
        if(ymod != 0):
            drivetrain.turn_to_heading(0, DEGREES)
            drivetrain.drive_for(REVERSE, ymod, MM)

def mapout():
    path = [[location.position(X,MM),location.position(Y,MM),0,0]]
    centre()
    while True:
        
        #follow left wall
        drivetrain.turn_for(LEFT, 90, DEGREES)
        while front_distance.get_distance(MM) <= 250:
            drivetrain.turn_for(RIGHT, 90, DEGREES)
        #brain.print(front_distance.get_distance(MM))
        #brain.new_line()
        if front_distance.get_distance(MM) > 2000:
            x = edgemove(250)
            if x == False:
                drivetrain.turn_for(LEFT, 180, DEGREES)
                continue

        else:
            drivetrain.drive_for(FORWARD, 250, MM)
        centre()
        path.append([location.position(X,MM),location.position(Y,MM),drivetrain.heading(DEGREES),250])
        if path[0][0] == location.position(X,MM) and path[0][1] == location.position(Y,MM):
            path2 = [(i[0],i[1]) for i in path]
            if (375,-875) in path2 and (125,-625) in path2 and (-125,-875) in path2:
                break


    return path
        

def compress_path(path,goal):#takes the path of a full circuit of the maze and returns the quickest path to the exit
    newpath = []
    
    for i in path:
        
        if i[0] == goal[0] and i[1] == goal[1]:#if we have reached the end
            newpath.append(i)
            break


        squad = [(item[0],item[1]) for item in newpath]
        if ((i[0],i[1]) in squad):#if the quords have been used before
            print(i)
            pl = len(newpath) #remove everything to last quordinate copy
            for j in reversed(newpath):
                print(j)
                print(newpath)
                if j[0] != i[0] or j[1] != i[1]:
                    print("killtime")
                    del newpath[-1]
                else:
                    break
        else:
            newpath.append(i)
    return newpath

def exec_path(path):
    for i in path:
        drivetrain.turn_to_heading(i[2],DEGREES)
        drivetrain.drive_for(FORWARD,i[3],MM)

def rev_path(path):
    path.reverse()
    for i in path:
        drivetrain.turn_to_heading(i[2],DEGREES)
        drivetrain.drive_for(REVERSE,i[3],MM)
