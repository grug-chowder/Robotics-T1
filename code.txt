#region VEXcode Generated Robot Configuration
import math
import random
from vexcode_vr import *

# Brain should be defined by default
brain=Brain()

drivetrain = Drivetrain("drivetrain", 0)
pen = Pen("pen", 8)
pen.set_pen_width(THIN)
left_bumper = Bumper("leftBumper", 2)
right_bumper = Bumper("rightBumper", 3)
front_eye = EyeSensor("frontEye", 4)
down_eye = EyeSensor("downEye", 5)
front_distance = Distance("frontdistance", 6)
distance = front_distance
magnet = Electromagnet("magnet", 7)
location = Location("location", 9)

#endregion VEXcode Generated Robot Configuration
myVariable = 0

#this code first maps out the maze into a set of movements that travel to every node
#this is  equivilent to a regular grid map as the mazes generated are "perfect"
#the movements are stored in the format [[x,y,angleto,distance],...]
#the path of the whole map is then trimed down into a path that goes direct to the finish as quick as posible
#that path is then further optimised by combineing instructions where posible

def when_started1():
    global myVariable
    drivetrain.set_drive_velocity(100, PERCENT)
    drivetrain.set_turn_velocity(100, PERCENT)

    centre()
    pen.move(DOWN)
    fpath = mapout()
    make_map(fpath)
    qpath = compress_path(fpath,[-125,875])
    pen.set_pen_color(RED)
    exec_path(qpath)
    rev_path(qpath)
    pen.set_pen_color(GREEN)
    exec_path(qpath)
    drivetrain.turn_to_heading(0, DEGREES)
    drivetrain.drive(FORWARD)
    pass

vr_thread(when_started1)

def edgemove(x):#checks if moves dont go out of bounds moveing if possible
    if ((drivetrain.heading(DEGREES) == 0 and 
        location.position(Y, MM) + x < 900) or
        (drivetrain.heading(DEGREES) == 180 and 
        location.position(Y, MM) - x > -900)):
        drivetrain.drive_for(FORWARD, x, MM)
        return True
    else:
        return False

        

    
def centre(): #centers bot to consistent position
    xmod,ymod = 1,1
    while xmod != 0  and ymod != 0:
        xmod = (location.position(X,MM) % 250) - 125
        ymod = (location.position(Y,MM) % 250) - 125

        
        if(xmod != 0):
            drivetrain.turn_to_heading(270, DEGREES)
            drivetrain.drive_for(FORWARD, xmod, MM)
        
        if(ymod != 0):
            drivetrain.turn_to_heading(0, DEGREES)
            drivetrain.drive_for(REVERSE, ymod, MM)

def mapout():
    path = [[location.position(X,MM),location.position(Y,MM),0,0]]
    centre()
    while True:
        
        #follow left wall
        drivetrain.turn_for(LEFT, 90, DEGREES)
        while front_distance.get_distance(MM) <= 250:
            drivetrain.turn_for(RIGHT, 90, DEGREES)
        if front_distance.get_distance(MM) > 2000:#if we can see into infinity we should be careful where we tread
            x = edgemove(250)
            if x == False:
                drivetrain.turn_for(LEFT, 180, DEGREES)
                continue

        else:
            drivetrain.drive_for(FORWARD, 250, MM)
        centre()
        path.append([location.position(X,MM),location.position(Y,MM),drivetrain.heading(DEGREES),250])
        if path[0][0] == location.position(X,MM) and path[0][1] == location.position(Y,MM):
            path2 = [(i[0],i[1]) for i in path]
            if (375,-875) in path2 and (125,-625) in path2 and (-125,-875) in path2:
                break


    return path
        

def compress_path(path,goal):#takes the path of a full circuit of the maze and returns the quickest path to the exit
    newpath = []
    
    for i in path:
        
        if i[0] == goal[0] and i[1] == goal[1]:#if we have reached the end
            newpath.append(i)
            break


        squad = [(item[0],item[1]) for item in newpath]
        if ((i[0],i[1]) in squad):#if the quords have been used before
            print(i)
            pl = len(newpath) #remove everything to last quordinate copy
            for j in reversed(newpath):
                print(j)
                print(newpath)
                if j[0] != i[0] or j[1] != i[1]:
                    print("killtime")
                    del newpath[-1]
                else:
                    break
        else:
            newpath.append(i)
    
    newpath2 = [newpath[0]]#seccond pass to optimise straight sections into single instructions
    for i in range(1,len(newpath)):
        if newpath[i][2] == newpath2[-1][2]:
            newpath2[-1][3] += 250
        else:
            newpath2.append(newpath[i])
        
    return newpath2

def exec_path(path):
    for i in path:
        drivetrain.turn_to_heading(i[2],DEGREES)
        drivetrain.drive_for(FORWARD,i[3],MM)

def rev_path(path):
    path.reverse()
    for i in path:
        drivetrain.turn_to_heading(i[2],DEGREES)
        drivetrain.drive_for(REVERSE,i[3],MM)
    path.reverse()

def make_map(path):
    amap = [[1 for i in range(17)] for i in range(17)]
    quords = [15,7]
    for i in path:
        amap[quords[0]][quords[1]] = 0
        if(i[3] != 0):
            if i[2] == 0:
                amap[quords[0] - 1][quords[1]] = 0
                quords = [quords[0] - 2,quords[1]]
            elif i[2] == 180:
                amap[quords[0] + 1][quords[1]] = 0
                quords = [quords[0] + 2,quords[1]]
            elif i[2] == 90:
                amap[quords[0]][quords[1] - 1] = 0
                quords = [quords[0],quords[1] - 2]
            elif i[2] == 270:
                amap[quords[0]][quords[1] + 1] = 0
                quords = [quords[0],quords[1] + 2]

    amap[15][7] = 8
    for i in amap:
        brain.print(i)
        brain.new_line()




